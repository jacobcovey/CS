/*
 * ExpresionManager.cpp
 *
 *  Created on: May 13, 2016
 *      Author: jcovey
 */
#include <iostream>
#include <string>
#include <vector>
#include <stack>
#include <locale>
#include "ExpresionManger.h"


using namespace std;
/*
* Checks whether an expression is balanced on its parentheses
*
* - The given expression will have a space between every number or operator
*
* @return true if expression is balanced
* @return false otherwise
*/

bool ExpressionManager::isBalanced(string expression){
	stack<char> stack;
	bool balanced = true;
	string::const_iterator iter = expression.begin();
	while(balanced && (iter != expression.end())){
		char next = *iter;
		if (isOpen(next)){
			stack.push(next);
		}
		else if (isClose(next)){
			if (stack.empty())
				balanced = false;
			else {
				char top = stack.top();
				stack.pop();
				balanced = isOpen(top) && compareBracketType(top,next);
			}
		}
		iter++;
	}

	return balanced && stack.empty();
}

/**
* Converts a postfix expression into an infix expression
* and returns the infix expression.
*
* - The given postfix expression will have a space between every number or operator.
* - The returned infix expression must have a space between every number or operator.
* - Redundant parentheses are acceptable i.e. ( ( 3 * 4 ) + 5 ).
* - Check lab requirements for what will be considered invalid.
*
* return the string "invalid" if postfixExpression is not a valid postfix expression.
* otherwise, return the correct infix expression as a string.
*/
string ExpressionManager::postfixToInfix(string postfixExpression){
	return "";
}

/*
* Converts an infix expression into a postfix expression
* and returns the postfix expression
*
* - The given infix expression will have a space between every number or operator.
* - The returned postfix expression must have a space between every number or operator.
* - Check lab requirements for what will be considered invalid.
*
* return the string "invalid" if infixExpression is not a valid infix expression.
* otherwise, return the correct postfix expression as a string.
*/
string ExpressionManager::infixToPostfix(string infixExpression){
	return "";
}

/*
* Evaluates a postfix expression returns the result as a string
*
* - The given postfix expression will have a space between every number or operator.
* - Check lab requirements for what will be considered invalid.
*
* return the string "invalid" if postfixExpression is not a valid postfix Expression
* otherwise, return the correct evaluation as a string
*/
string ExpressionManager::postfixEvaluate(string postfixExpression){
	return "";
}

bool ExpressionManager::isOpen(char bracket) {

	for (int x = 0; x < 3; x++){
		if (bracket == OPEN[x])
			return true;
	}
	return false;
}

bool ExpressionManager::isClose(char bracket) {

	for (int x = 0; x < 3; x++){
		if (bracket == CLOSE[x])
			return true;
	}
	return false;
}

bool ExpressionManager::compareBracketType (char open, char close){
	int openBraketType = -1;
	int closeBraketType = -2;

	for (int x = 0; x < 3; x++){
			if (open == OPEN[x])
				openBraketType = x;
		}
	for (int x = 0; x < 3; x++){
			if (close == CLOSE[x])
				closeBraketType = x;
		}

	return openBraketType == closeBraketType;

}

string ExpressionManager::determineCharType (char input){
	string charType = "";
	if (isdigit(input))
		charType = "operand";
	else if (isOpen(input) || isClose(input))
		charType = "bracket";
	else {
		for (int x = 0; x < OPERATOR.length(); x++){
			if (input == OPERATOR[x])
				charType = "operator";
		}
	if (charType == "")
		charType = "other";
	}
	return charType;
}

